["при записі нового","use arboard::Clipboard;\nuse rdev::{listen, EventType, Key};\nuse std::collections::HashSet;\nuse std::fs;\nuse std::sync::mpsc::{self, Receiver, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::{thread, time::Duration};\nuse tauri::SystemTrayMenuItem;\nuse tauri::{CustomMenuItem, SystemTray, SystemTrayEvent, SystemTrayMenu};\n\n// Файл збереження історії буферу обміну\nconst HISTORY_FILE: &str = \"clipboard_history.json\";\n\n// Збереження історії буферу обміну в файл\nfn save_history(history: &Vec<String>) {\n    let json = serde_json::to_string(history).unwrap();\n    fs::write(HISTORY_FILE, json).expect(\"Unable to write history file\");\n}\n\n// Завантаження історію буферу обміну з файлу\nfn load_history() -> Vec<String> {\n    if let Ok(json) = fs::read_to_string(HISTORY_FILE) {\n        serde_json::from_str(&json).unwrap_or_else(|_| Vec::new())\n    } else {\n        Vec::new()\n    }\n}\n\n// Додає текст до історії буфера обміну\nfn add_to_clipboard_history(\n    text: String,\n    clipboard_history: &mut Vec<String>,\n    sender: &Sender<()>,\n) {\n    if clipboard_history.len() >= 5 {\n        clipboard_history.remove(0);\n    }\n    clipboard_history.push(text);\n    save_history(clipboard_history);\n    sender.send(()).unwrap();\n}\n\n// Створює меню системного tray на основі історії буфера обміну та стану прослуховування\nfn create_tray_menu(clipboard_history: &Vec<String>, is_listen: bool) -> SystemTrayMenu {\n    let mut tray_menu = SystemTrayMenu::new();\n    if clipboard_history.is_empty() {\n        tray_menu = tray_menu\n            .add_item(CustomMenuItem::new(\"empty\".to_string(), \"Copy something...\").disabled());\n    } else {\n        for (index, item) in clipboard_history.iter().enumerate() {\n            let mut title = item.clone();\n            if title.chars().count() > 15 {\n                title = title.chars().take(15).collect::<String>() + \"...\";\n            }\n            let button = CustomMenuItem::new(index.to_string(), title);\n            tray_menu = tray_menu.add_item(button);\n        }\n    }\n    let listen_stop_text = if is_listen {\n        \"Pause listening\"\n    } else {\n        \"Listen\"\n    };\n    let listen_stop_button =\n        CustomMenuItem::new(\"change_listen_state\".to_string(), listen_stop_text);\n    let clear = CustomMenuItem::new(\"clear\".to_string(), \"Clear\");\n    let quit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\");\n    tray_menu\n        .add_native_item(SystemTrayMenuItem::Separator)\n        .add_item(listen_stop_button)\n        .add_item(clear)\n        .add_item(quit)\n}\n\nfn main() {\n    // Ініціалізація змінних відповідальних за слухання буферу обміну\n    let is_listen: Arc<Mutex<bool>> = Arc::new(Mutex::new(true));\n    let just_started_listening: Arc<Mutex<bool>> = Arc::new(Mutex::new(false));\n\n    // Змінна що відповідає за ініціалізацію історії буферу обміну\n    let initial_history = load_history();\n\n    // Ініціалізація змінних відповідальних за\n    let clipboard_history: Arc<Mutex<Vec<String>>> = Arc::new(Mutex::new(initial_history));\n    let clipboard_history_clone = clipboard_history.clone();\n    let pressed_keys = Arc::new(Mutex::new(HashSet::new()));\n    let pressed_keys_clone = pressed_keys.clone();\n    let (sender, receiver): (Sender<()>, Receiver<()>) = mpsc::channel();\n\n    let app = tauri::Builder::default()\n        .plugin(tauri_plugin_clipboard::init())\n        .system_tray(SystemTray::new().with_menu(create_tray_menu(\n            &clipboard_history.lock().unwrap(),\n            *is_listen.lock().unwrap(),\n        )))\n        .on_system_tray_event({\n            let clipboard_history = clipboard_history.clone();\n            let is_listen = is_listen.clone();\n            let just_started_listening = just_started_listening.clone();\n            move |_app, event| {\n                if let SystemTrayEvent::MenuItemClick { id, .. } = event {\n                    let mut clipboard_history = clipboard_history.lock().unwrap();\n                    match id.as_str() {\n                        \"change_listen_state\" => {\n                            let mut is_listen_guard = is_listen.lock().unwrap();\n                            *is_listen_guard = !*is_listen_guard;\n                            println!(\"Change listen state on: {}\", *is_listen_guard);\n                            if *is_listen_guard {\n                                let mut just_started_listening_guard =\n                                    just_started_listening.lock().unwrap();\n                                *just_started_listening_guard = true;\n                            }\n                            let tray_menu = create_tray_menu(&clipboard_history, *is_listen_guard);\n                            _app.tray_handle().set_menu(tray_menu).unwrap();\n                        }\n                        \"clear\" => {\n                            clipboard_history.clear();\n                            save_history(&clipboard_history);\n                            let tray_menu =\n                                create_tray_menu(&clipboard_history, *is_listen.lock().unwrap());\n                            _app.tray_handle().set_menu(tray_menu).unwrap();\n                        }\n                        \"quit\" => {\n                            std::process::exit(0);\n                        }\n                        _ => {\n                            if let Ok(index) = id.parse::<usize>() {\n                                if let Some(item) = clipboard_history.get(index) {\n                                    println!(\"Menu item {} clicked: {}\", index, item);\n                                    let mut clipboard = Clipboard::new().unwrap();\n                                    clipboard.set_text(item.clone()).unwrap();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        .build(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n\n    let app_handle = app.handle();\n\n    // Потік для прослуховування клавіш\n    std::thread::spawn({\n        let app_handle = app_handle.clone();\n        let sender_clone = sender.clone();\n        let is_listen_clone = is_listen.clone();\n        let clipboard_history_clone_for_thread = clipboard_history.clone();\n        move || {\n            listen(move |event| {\n                let mut keys = pressed_keys_clone.lock().unwrap();\n                match event.event_type {\n                    EventType::KeyPress(key) => {\n                        keys.insert(key);\n                        if keys.contains(&Key::ControlLeft) && keys.contains(&Key::KeyC) {\n                            println!(\"Ctrl+C pressed!\");\n                            let is_listen = is_listen_clone.clone();\n                            let clipboard_history = clipboard_history_clone_for_thread.clone();\n                            let sender = sender_clone.clone();\n\n                            if *is_listen.lock().unwrap() {\n                                // Затримка в пів секунди\n                                thread::spawn(move || {\n                                    thread::sleep(Duration::from_millis(500));\n                                    if *is_listen.lock().unwrap() {\n                                        let mut clipboard = Clipboard::new().unwrap();\n                                        let current_text = clipboard.get_text().unwrap_or_default();\n                                        let mut clipboard_history =\n                                            clipboard_history.lock().unwrap();\n                                        add_to_clipboard_history(\n                                            current_text,\n                                            &mut clipboard_history,\n                                            &sender,\n                                        );\n                                    }\n                                });\n                            }\n                        }\n                        if keys.contains(&Key::ControlLeft)\n                            && keys.contains(&Key::Alt)\n                            && keys.contains(&Key::KeyV)\n                        {\n                            println!(\"Ctrl+Alt+V pressed!\");\n                            let clipboard_history = clipboard_history_clone.lock().unwrap();\n                            println!(\"{}\", clipboard_history.join(\", \"));\n\n                            let tray_menu = create_tray_menu(\n                                &clipboard_history,\n                                *is_listen_clone.lock().unwrap(),\n                            );\n                            let _ = app_handle.tray_handle().set_menu(tray_menu);\n                        }\n                    }\n                    EventType::KeyRelease(key) => {\n                        keys.remove(&key);\n                    }\n                    _ => {}\n                }\n            })\n            .unwrap();\n        }\n    });\n\n    // Потік для оновлення меню системного tray при зміні історії буфера обміну\n    std::thread::spawn({\n        let clipboard_history_clone_for_thread = clipboard_history.clone();\n        let is_listen_clone = is_listen.clone();\n        move || {\n            while let Ok(_) = receiver.recv() {\n                let clipboard_history = clipboard_history_clone_for_thread.lock().unwrap();\n                let tray_menu =\n                    create_tray_menu(&clipboard_history, *is_listen_clone.lock().unwrap());\n                let _ = app_handle.tray_handle().set_menu(tray_menu);\n            }\n        }\n    });\n\n    // Запуск Tauri додатку\n    app.run(|_, _| {});\n}\n","при натисканні на Ctrl+Alt+V відкривати tray меню","збереження","clipboard_history"]